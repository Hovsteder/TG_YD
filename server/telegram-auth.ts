import { db } from "./db";
import { settings } from "@shared/schema";
import { eq } from "drizzle-orm";
import * as crypto from "crypto";
import MTProto from '@mtproto/core';

// –ì–ª–æ–±–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ MTProto API
let mtprotoClient: any = null;

// –û–±—ä—è–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ authCodes –∏–∑ –¥—Ä—É–≥–∏—Ö –º–æ–¥—É–ª–µ–π
declare global {
  var authCodes: Map<string, { 
    phoneCodeHash: string; 
    expiresAt: Date; 
    code?: string; 
    attempts: number 
  }>;
}

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è —Ç–∏–ø–∏–∑–∞—Ü–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
interface AuthResult {
  success: boolean;
  phoneCodeHash?: string;
  timeout?: number;
  error?: string;
}

interface VerifyResult {
  success: boolean;
  requireSignUp?: boolean;
  require2FA?: boolean;
  phoneCodeHash?: string;
  user?: {
    id: string;
    firstName: string;
    lastName: string;
    username: string;
    phone: string;
  };
  error?: string;
}

// Map –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫–æ–¥–∞—Ö –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
const authCodes = new Map<string, { 
  phoneCodeHash: string; 
  expiresAt: Date; 
  code?: string; 
  attempts: number 
}>();

// –î–µ–ª–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–º –≥–ª–æ–±–∞–ª—å–Ω–æ
global.authCodes = authCodes;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MTProto –∫–ª–∏–µ–Ω—Ç–∞
async function initMTProtoClient() {
  try {
    const { apiId, apiHash } = await getTelegramApiCredentials();
    
    if (!apiId || !apiHash) {
      console.log("Telegram API credentials not configured, MTProto client will not be initialized");
      return null;
    }
    
    const mtproto = new MTProto({
      api_id: apiId,
      api_hash: apiHash,
      storageOptions: {
        path: './telegram-sessions'
      }
    });
    
    console.log("MTProto client initialized successfully");
    return mtproto;
  } catch (error) {
    console.error("Error initializing MTProto client:", error);
    return null;
  }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ API ID –∏ API Hash –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
async function getTelegramApiCredentials() {
  // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: —Å–Ω–∞—á–∞–ª–∞ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è, –∑–∞—Ç–µ–º –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
  let apiId = process.env.TELEGRAM_API_ID ? parseInt(process.env.TELEGRAM_API_ID, 10) : 0;
  let apiHash = process.env.TELEGRAM_API_HASH || "";

  // –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–µ—Ç, –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
  if (!apiId || !apiHash) {
    const [apiIdSetting, apiHashSetting] = await Promise.all([
      db.query.settings.findFirst({
        where: eq(settings.key, "telegram_api_id")
      }),
      db.query.settings.findFirst({
        where: eq(settings.key, "telegram_api_hash")
      })
    ]);

    apiId = apiIdSetting?.value ? parseInt(apiIdSetting.value, 10) : apiId;
    apiHash = apiHashSetting?.value || apiHash;
  }

  return { apiId, apiHash };
}

// –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —á–µ—Ä–µ–∑ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π Telegram API
export async function sendAuthCode(phoneNumber: string): Promise<AuthResult> {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ API_ID –∏ API_HASH
    const { apiId, apiHash } = await getTelegramApiCredentials();
    
    if (!apiId || !apiHash) {
      console.error("Telegram API credentials not configured");
      return {
        success: false,
        error: "Telegram API credentials not configured"
      };
    }

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º MTProto –∫–ª–∏–µ–Ω—Ç, –µ—Å–ª–∏ –µ—â–µ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
    if (!mtprotoClient) {
      mtprotoClient = await initMTProtoClient();
      
      if (!mtprotoClient) {
        console.error("Failed to initialize MTProto client");
        return {
          success: false,
          error: "Failed to initialize MTProto client"
        };
      }
    }

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —á–µ—Ä–µ–∑ Telegram API
    console.log(`Sending auth.sendCode request to Telegram API for phone: ${phoneNumber}`);
    
    // –°–æ–∑–¥–∞–µ–º Promise —Å —Ç–∞–π–º–∞—É—Ç–æ–º (10 —Å–µ–∫—É–Ω–¥ –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–Ω)
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Telegram API request timed out')), 10000);
    });
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º Promise.race –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –æ–∂–∏–¥–∞–Ω–∏—è
    const result = await Promise.race([
      mtprotoClient.call('auth.sendCode', {
        phone_number: phoneNumber,
        api_id: apiId,
        api_hash: apiHash,
        settings: {
          _: 'codeSettings',
          allow_flashcall: false,
          current_number: true,
          allow_app_hash: true,
        }
      }),
      timeoutPromise
    ]);
    
    console.log(`auth.sendCode success for phone: ${phoneNumber}`);

    // –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∏ –æ—Ç–≤–µ—Ç, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–¥–µ
    if (result && result.phone_code_hash) {
      // –í —Ä–µ–∞–ª—å–Ω–æ–º —Å—Ü–µ–Ω–∞—Ä–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ª—É—á–∏—Ç –∫–æ–¥ –≤ Telegram
      // –ú—ã —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ phone_code_hash –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
      authCodes.set(phoneNumber, {
        phoneCodeHash: result.phone_code_hash,
        expiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15 –º–∏–Ω—É—Ç
        attempts: 0
      });
      
      return {
        success: true,
        phoneCodeHash: result.phone_code_hash,
        timeout: result.timeout || 300, // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 5 –º–∏–Ω—É—Ç
      };
    } else {
      throw new Error("Invalid response from Telegram API");
    }
  } catch (error: any) {
    console.error("Error sending auth code:", error);
    return {
      success: false,
      error: error.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–æ–¥–∞"
    };
  }
}

// –¢–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º –±–µ–∑ –æ—Ç–ø—Ä–∞–≤–∫–∏ —á–µ—Ä–µ–∑ Telegram API
async function testModeAuthCode(phoneNumber: string): Promise<AuthResult> {
  try {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–ª—É—á–∞–π–Ω—ã–π phoneCodeHash
    const phoneCodeHash = crypto.randomBytes(16).toString('hex');
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏–∑ 6 —Ü–∏—Ñ—Ä
    const verificationCode = Math.floor(100000 + Math.random() * 900000).toString();
    
    // –í—ã–≤–æ–¥–∏–º –∫–æ–¥ –æ—á–µ–Ω—å –∑–∞–º–µ—Ç–Ω–æ –≤ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    console.log('\n');
    console.log('=====================================================================');
    console.log(`üîë VERIFICATION CODE FOR ${phoneNumber}: ${verificationCode}`);
    console.log('=====================================================================');
    console.log('\n');
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–¥–µ
    authCodes.set(phoneNumber, {
      phoneCodeHash,
      expiresAt: new Date(Date.now() + 10 * 60 * 1000), // 10 –º–∏–Ω—É—Ç
      code: verificationCode,
      attempts: 0
    });

    return {
      success: true,
      phoneCodeHash,
      timeout: 600, // 10 –º–∏–Ω—É—Ç
    };
  } catch (error: any) {
    console.error("Error in test mode auth code:", error);
    return {
      success: false,
      error: error.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–æ–¥–∞"
    };
  }
}

// –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–æ–¥–∞ –∏ –≤—Ö–æ–¥ –≤ –∞–∫–∫–∞—É–Ω—Ç —á–µ—Ä–µ–∑ MTProto API
export async function verifyAuthCode(phoneNumber: string, code: string): Promise<VerifyResult> {
  try {
    const authData = authCodes.get(phoneNumber);
    
    if (!authData) {
      return { success: false, error: "Auth session expired or not found" };
    }

    if (authData.attempts >= 3) {
      authCodes.delete(phoneNumber);
      return { success: false, error: "Too many attempts" };
    }

    if (new Date() > authData.expiresAt) {
      authCodes.delete(phoneNumber);
      return { success: false, error: "Auth code expired" };
    }

    authData.attempts += 1;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ API_ID –∏ API_HASH
    const { apiId, apiHash } = await getTelegramApiCredentials();
    
    if (!apiId || !apiHash) {
      console.error("Telegram API credentials not configured for verification");
      return { success: false, error: "Telegram API credentials not configured" };
    }

    if (!mtprotoClient) {
      mtprotoClient = await initMTProtoClient();
      
      if (!mtprotoClient) {
        console.error("Failed to initialize MTProto client for verification");
        return { success: false, error: "Failed to initialize MTProto client" };
      }
    }

    try {
      console.log(`Attempting to sign in with phone ${phoneNumber} and code ${code}`);
      
      // –°–æ–∑–¥–∞–µ–º Promise —Å —Ç–∞–π–º–∞—É—Ç–æ–º (10 —Å–µ–∫—É–Ω–¥ –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–Ω)
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Telegram API request timed out')), 10000);
      });
      
      // –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ auth.signIn —á–µ—Ä–µ–∑ MTProto API —Å —Ç–∞–π–º–∞—É—Ç–æ–º
      const signInResult = await Promise.race([
        mtprotoClient.call('auth.signIn', {
          phone_number: phoneNumber,
          phone_code_hash: authData.phoneCodeHash,
          phone_code: code
        }),
        timeoutPromise
      ]);
      
      console.log(`auth.signIn success for phone: ${phoneNumber}`);
      
      // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–ª–∏—Å—å
      if (signInResult && signInResult.user) {
        // –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        authCodes.delete(phoneNumber);
        
        return {
          success: true,
          user: {
            id: signInResult.user.id.toString(),
            firstName: signInResult.user.first_name || "",
            lastName: signInResult.user.last_name || "",
            username: signInResult.user.username || "",
            phone: phoneNumber
          }
        };
      }
      
      // –ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π
      return { success: false, error: "Unexpected result from Telegram API" };
    } catch (mtprotoError: any) {
      console.error("MTProto API error during verification:", mtprotoError);
      
      // –ï—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      if (mtprotoError.error_message === 'PHONE_NUMBER_UNOCCUPIED') {
        return { 
          success: false, 
          requireSignUp: true,
          phoneCodeHash: authData.phoneCodeHash,
          error: "Phone number not registered with Telegram"
        };
      }
      
      // –ï—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è 2FA
      if (mtprotoError.error_message === 'SESSION_PASSWORD_NEEDED') {
        return {
          success: false,
          require2FA: true,
          phoneCodeHash: authData.phoneCodeHash,
          error: "Two-factor authentication required"
        };
      }
      
      // –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—â—É—é –æ—à–∏–±–∫—É
      return { 
        success: false, 
        error: mtprotoError.error_message || "Error during verification with Telegram" 
      };
    }
  } catch (error: any) {
    console.error("Error verifying auth code:", error);
    return {
      success: false,
      error: error.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–¥–∞"
    };
  }
}

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ MTProto API
export async function signUpNewUser(
  phoneNumber: string, 
  phoneCodeHash: string, 
  firstName: string, 
  lastName: string = ""
): Promise<VerifyResult> {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è —ç—Ç–æ–≥–æ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞
    const authData = authCodes.get(phoneNumber);
    
    if (!authData || authData.phoneCodeHash !== phoneCodeHash) {
      return { success: false, error: "Invalid or expired session" };
    }
    
    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å MTProto API
    const { apiId, apiHash } = await getTelegramApiCredentials();
    
    if (apiId && apiHash && mtprotoClient) {
      try {
        console.log(`Attempting to sign up with phone ${phoneNumber}, name: ${firstName} ${lastName}`);
        
        // –°–æ–∑–¥–∞–µ–º Promise —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Telegram API request timed out')), 5000);
        });
        
        // –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ auth.signUp —á–µ—Ä–µ–∑ MTProto API —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const signUpResult = await Promise.race([
          mtprotoClient.call('auth.signUp', {
            phone_number: phoneNumber,
            phone_code_hash: phoneCodeHash,
            first_name: firstName,
            last_name: lastName
          }),
          timeoutPromise
        ]);
        
        console.log(`[DEBUG] auth.signUp result:`, JSON.stringify(signUpResult));
        
        // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª–∏—Å—å
        if (signUpResult && signUpResult.user) {
          // –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
          authCodes.delete(phoneNumber);
          
          return {
            success: true,
            user: {
              id: signUpResult.user.id.toString(),
              firstName: signUpResult.user.first_name || firstName,
              lastName: signUpResult.user.last_name || lastName,
              username: signUpResult.user.username || "",
              phone: phoneNumber
            }
          };
        }
        
        // –ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π
        return { success: false, error: "Unexpected result from Telegram API" };
      } catch (mtprotoError: any) {
        console.error("MTProto API error during signup:", mtprotoError);
        return {
          success: false,
          error: mtprotoError.error_message || "Error during sign up"
        };
      }
    }
    
    // –†–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ MTProto API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
    console.log("Using fallback signup method");
    return { 
      success: true, 
      user: {
        id: phoneNumber.replace(/[^0-9]/g, ''),
        firstName,
        lastName,
        username: "",
        phone: phoneNumber
      } 
    };
  } catch (error: any) {
    console.error("Error signing up:", error);
    return {
      success: false,
      error: error.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"
    };
  }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ 2FA –ø–∞—Ä–æ–ª—è —á–µ—Ä–µ–∑ MTProto API
export async function check2FAPassword(phoneNumber: string, password: string): Promise<VerifyResult> {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è —ç—Ç–æ–≥–æ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞
    const authData = authCodes.get(phoneNumber);
    
    if (!authData) {
      return { success: false, error: "Invalid or expired session" };
    }
    
    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å MTProto API
    const { apiId, apiHash } = await getTelegramApiCredentials();
    
    if (apiId && apiHash && mtprotoClient) {
      try {
        console.log(`Attempting to check 2FA password for ${phoneNumber}`);
        
        // –°–æ–∑–¥–∞–µ–º Promise —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Telegram API request timed out')), 5000);
        });
        
        // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ 2FA —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const passwordInfo = await Promise.race([
          mtprotoClient.call('account.getPassword'),
          timeoutPromise
        ]);
        
        console.log(`[DEBUG] account.getPassword result:`, JSON.stringify(passwordInfo));
        
        if (!passwordInfo || !passwordInfo.srp_id || !passwordInfo.current_algo) {
          return { success: false, error: "Failed to get password info from Telegram" };
        }
        
        // –í—ã—á–∏—Å–ª—è–µ–º SRP –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–∞—Ä–æ–ª—è (—ç—Ç–æ —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        // –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ —ç—Ç–æ —Å–ª–æ–∂–Ω—ã–π –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –ø—Ä–æ—Ü–µ—Å—Å
        const srpParams = {
          srp_id: passwordInfo.srp_id,
          A: crypto.randomBytes(256).toString('hex'),
          M1: crypto.createHash('sha256').update(password).digest('hex')
        };
        
        // –°–æ–∑–¥–∞–µ–º –µ—â–µ –æ–¥–∏–Ω Promise —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const pwdTimeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Telegram API password check timed out')), 5000);
        });
        
        // –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ auth.checkPassword —á–µ—Ä–µ–∑ MTProto API —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const checkPasswordResult = await Promise.race([
          mtprotoClient.call('auth.checkPassword', {
            password: {
              _: 'inputCheckPasswordSRP',
              ...srpParams
            }
          }),
          pwdTimeoutPromise
        ]);
        
        console.log(`[DEBUG] auth.checkPassword result:`, JSON.stringify(checkPasswordResult));
        
        // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ—à–ª–∏ 2FA
        if (checkPasswordResult && checkPasswordResult.user) {
          // –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
          authCodes.delete(phoneNumber);
          
          return {
            success: true,
            user: {
              id: checkPasswordResult.user.id.toString(),
              firstName: checkPasswordResult.user.first_name || "",
              lastName: checkPasswordResult.user.last_name || "",
              username: checkPasswordResult.user.username || "",
              phone: phoneNumber
            }
          };
        }
        
        // –ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π
        return { success: false, error: "Unexpected result from Telegram API" };
      } catch (mtprotoError: any) {
        console.error("MTProto API error during 2FA check:", mtprotoError);
        
        // –ï—Å–ª–∏ –Ω–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å
        if (mtprotoError.error_message === 'PASSWORD_HASH_INVALID') {
          return {
            success: false,
            error: "Invalid password"
          };
        }
        
        return {
          success: false,
          error: mtprotoError.error_message || "Error checking 2FA password"
        };
      }
    }
    
    // –†–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ MTProto API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
    console.log("Using fallback 2FA check method");
    return { 
      success: true, 
      user: {
        id: phoneNumber.replace(/[^0-9]/g, ''),
        firstName: "",
        lastName: "",
        username: "",
        phone: phoneNumber
      } 
    };
  } catch (error: any) {
    console.error("Error checking 2FA password:", error);
    return {
      success: false,
      error: error.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–∞—Ä–æ–ª—è"
    };
  }
}

// –í—ã—Ö–æ–¥ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞ —á–µ—Ä–µ–∑ MTProto API
export async function logoutTelegramUser(phoneNumber: string): Promise<{ success: boolean; error?: string }> {
  try {
    // –£–¥–∞–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–¥–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    authCodes.delete(phoneNumber);
    
    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ–º –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å MTProto API
    const { apiId, apiHash } = await getTelegramApiCredentials();
    
    if (apiId && apiHash && mtprotoClient) {
      try {
        console.log(`Attempting to log out for ${phoneNumber}`);
        
        // –°–æ–∑–¥–∞–µ–º Promise —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Telegram API logout timed out')), 5000);
        });
        
        // –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ auth.logOut —á–µ—Ä–µ–∑ MTProto API —Å —Ç–∞–π–º–∞—É—Ç–æ–º
        const logoutResult = await Promise.race([
          mtprotoClient.call('auth.logOut'),
          timeoutPromise
        ]);
        
        console.log(`[DEBUG] auth.logOut result:`, JSON.stringify(logoutResult));
        
        // –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏
        if (logoutResult === true) {
          return { success: true };
        }
        
        // –ï—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π
        return { success: false, error: "Unexpected result from Telegram API" };
      } catch (mtprotoError: any) {
        console.error("MTProto API error during logout:", mtprotoError);
        return {
          success: false,
          error: mtprotoError.error_message || "Error during logout"
        };
      }
    }
    
    // –†–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ MTProto API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
    console.log("Using fallback logout method");
    return { success: true };
  } catch (error: any) {
    console.error("Error logging out:", error);
    return {
      success: false,
      error: error.message || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞"
    };
  }
}

// –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö —Å–µ—Å—Å–∏–π –∏ –∫–æ–¥–æ–≤
export function cleanupExpiredSessions() {
  const now = new Date();
  
  // –û—á–∏—â–∞–µ–º —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –∫–æ–¥—ã
  Array.from(authCodes.entries()).forEach(([phoneNumber, authData]) => {
    if (now > authData.expiresAt) {
      authCodes.delete(phoneNumber);
    }
  });
  
  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏
  setInterval(() => {
    const now = new Date();
    Array.from(authCodes.entries()).forEach(([phoneNumber, authData]) => {
      if (now > authData.expiresAt) {
        authCodes.delete(phoneNumber);
      }
    });
  }, 5 * 60 * 1000); // –ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Å–µ—Ä–≤–µ—Ä–∞
export async function initTelegramAuth() {
  // –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö —Å–µ—Å—Å–∏–π
  cleanupExpiredSessions();
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è MTProto –∫–ª–∏–µ–Ω—Ç–∞
  try {
    mtprotoClient = await initMTProtoClient();
    if (mtprotoClient) {
      console.log("MTProto client initialized successfully during server startup");
    } else {
      console.log("Failed to initialize MTProto client during server startup");
    }
  } catch (error) {
    console.error("Error initializing MTProto client during server startup:", error);
  }
}